"""
Agent Evolver - Génère automatiquement de nouveaux agents spécialisés

Responsabilités:
- Détecte besoin de nouveaux agents basé sur patterns
- Génère code Python pour agents
- Détermine niveau approprié (EXÉCUTANT/EXPERT/DIRECTEUR)
- Crée tests unitaires automatiquement
"""

from typing import List, Dict, Any
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path

from cortex.core.auto_evolution.pattern_detector import DetectedPattern


@dataclass
class GeneratedAgent:
    """Agent généré automatiquement"""
    name: str
    class_name: str
    role: str  # "EXÉCUTANT", "EXPERT", "DIRECTEUR"
    department: str
    specialization: str
    description: str
    code_content: str
    test_content: str
    created_at: datetime
    pattern_id: str
    estimated_improvement: Dict[str, float]  # success_rate, duration


class AgentEvolver:
    """Générateur automatique d'agents"""

    def __init__(self, agents_dir: str = "cortex/agents/generated"):
        self.agents_dir = Path(agents_dir)
        self.agents_dir.mkdir(parents=True, exist_ok=True)

    def should_create_agent(self, pattern: DetectedPattern) -> bool:
        """Détermine si un agent devrait être créé"""
        return (
            pattern.recommended_evolution == "agent" or
            (pattern.frequency >= 5 and pattern.success_rate < 0.7)
        )

    def generate_agent_from_pattern(self, pattern: DetectedPattern) -> GeneratedAgent:
        """Génère un agent depuis un pattern"""

        # Déterminer niveau
        if pattern.complexity_score > 0.7:
            role = "EXPERT"
        elif pattern.complexity_score > 0.4:
            role = "EXÉCUTANT"
        else:
            role = "EXÉCUTANT"

        # Générer nom de classe
        class_name = self._generate_class_name(pattern, role)

        # Déterminer département
        department = self._infer_department(pattern)

        # Générer code
        code_content = self._generate_agent_code(
            class_name, role, department, pattern
        )

        # Générer tests
        test_content = self._generate_test_code(class_name, pattern)

        return GeneratedAgent(
            name=class_name.lower(),
            class_name=class_name,
            role=role,
            department=department,
            specialization=pattern.name,
            description=pattern.description,
            code_content=code_content,
            test_content=test_content,
            created_at=datetime.now(),
            pattern_id=pattern.id,
            estimated_improvement={
                "success_rate": 0.95 - pattern.success_rate,
                "duration_reduction": pattern.avg_duration * 0.4
            }
        )

    def _generate_class_name(self, pattern: DetectedPattern, role: str) -> str:
        """Génère nom de classe CamelCase"""
        keywords = pattern.keywords[:2]
        name_parts = [k.capitalize() for k in keywords]
        name_parts.append(role.capitalize())
        return "".join(name_parts)

    def _infer_department(self, pattern: DetectedPattern) -> str:
        """Infère département approprié"""
        keywords_lower = [k.lower() for k in pattern.keywords]

        if any(k in keywords_lower for k in ["security", "audit", "vulnerability"]):
            return "security"
        elif any(k in keywords_lower for k in ["test", "testing", "pytest"]):
            return "testing"
        elif any(k in keywords_lower for k in ["doc", "documentation"]):
            return "documentation"
        else:
            return "development"

    def _generate_agent_code(
        self, class_name: str, role: str, department: str, pattern: DetectedPattern
    ) -> str:
        """Génère le code Python de l'agent"""

        code = f'''"""
Auto-generated Agent: {class_name}

Created: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
Pattern: {pattern.id}
Description: {pattern.description}

Generated by AgentEvolver
Estimated improvement: {pattern.potential_success_improvement:.1%} success rate
"""

from typing import Dict, Any, List
from datetime import datetime


class {class_name}:
    """
    {pattern.description}

    Role: {role}
    Department: {department}
    Specialization: {pattern.name}

    This agent was auto-generated based on {pattern.frequency} similar requests
    with {pattern.success_rate:.1%} success rate.
    """

    def __init__(self):
        self.role = "{role}"
        self.department = "{department}"
        self.created_at = datetime.now()
        self.executions = 0
        self.successes = 0

    def execute(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute the specialized task

        Args:
            task: Task dictionary with parameters

        Returns:
            Result dictionary with outcome
        """
        self.executions += 1

        try:
            # TODO: Implement specific logic for {pattern.name}
            # Based on pattern keywords: {", ".join(pattern.keywords[:3])}
            # Tools available: {", ".join(pattern.tools_used) if pattern.tools_used else "none"}

            result = self._perform_task(task)

            self.successes += 1

            return {{
                "success": True,
                "result": result,
                "agent": "{class_name}",
                "timestamp": datetime.now().isoformat()
            }}

        except Exception as e:
            return {{
                "success": False,
                "error": str(e),
                "agent": "{class_name}",
                "timestamp": datetime.now().isoformat()
            }}

    def _perform_task(self, task: Dict[str, Any]) -> Any:
        """
        Core task implementation

        TODO: Customize this method based on specific needs
        """
        # Placeholder implementation
        return {{"status": "completed", "details": "Task performed"}}

    def get_stats(self) -> Dict[str, Any]:
        """Get agent performance statistics"""
        success_rate = self.successes / self.executions if self.executions > 0 else 0

        return {{
            "executions": self.executions,
            "successes": self.successes,
            "success_rate": success_rate,
            "role": self.role,
            "department": self.department
        }}


def create_{class_name.lower()}() -> {class_name}:
    """Factory function"""
    return {class_name}()
'''
        return code

    def _generate_test_code(self, class_name: str, pattern: DetectedPattern) -> str:
        """Génère les tests unitaires"""

        test_code = f'''"""
Tests for auto-generated agent: {class_name}
"""

import pytest
from cortex.agents.generated.{class_name.lower()} import {class_name}, create_{class_name.lower()}


def test_{class_name.lower()}_creation():
    """Test agent creation"""
    agent = create_{class_name.lower()}()

    assert agent is not None
    assert agent.role == "{agent.role if hasattr(locals().get('agent'), 'role') else 'EXÉCUTANT'}"
    assert agent.executions == 0


def test_{class_name.lower()}_execute():
    """Test agent execution"""
    agent = create_{class_name.lower()}()

    task = {{"input": "test_data"}}
    result = agent.execute(task)

    assert "success" in result
    assert "agent" in result
    assert result["agent"] == "{class_name}"


def test_{class_name.lower()}_stats():
    """Test stats tracking"""
    agent = create_{class_name.lower()}()

    # Execute some tasks
    agent.execute({{"input": "test1"}})
    agent.execute({{"input": "test2"}})

    stats = agent.get_stats()

    assert stats["executions"] == 2
    assert "success_rate" in stats
'''
        return test_code

    def save_agent(self, agent: GeneratedAgent) -> Path:
        """Sauvegarde l'agent généré"""
        # Sauvegarder code agent
        agent_path = self.agents_dir / f"{agent.name}.py"
        with open(agent_path, 'w', encoding='utf-8') as f:
            f.write(agent.code_content)

        # Sauvegarder tests
        test_dir = Path("tests/generated")
        test_dir.mkdir(parents=True, exist_ok=True)
        test_path = test_dir / f"test_{agent.name}.py"
        with open(test_path, 'w', encoding='utf-8') as f:
            f.write(agent.test_content)

        print(f"✓ Agent saved: {agent_path}")
        print(f"  Test: {test_path}")
        print(f"  Role: {agent.role}")
        print(f"  Department: {agent.department}")

        return agent_path


# Test
if __name__ == "__main__":
    print("Testing Agent Evolver...")

    from cortex.core.auto_evolution.pattern_detector import DetectedPattern
    from datetime import datetime

    # Mock pattern
    pattern = DetectedPattern(
        id="pattern_security_001",
        name="Security Audit",
        description="Perform comprehensive security audit",
        frequency=8,
        success_rate=0.625,
        avg_duration=1800,
        avg_cost=0.05,
        keywords=["security", "audit", "vulnerabilities"],
        agents_involved=["CodeAnalyst"],
        tools_used=["grep", "find"],
        workflows_used=["security_check"],
        complexity_score=0.75,
        example_requests=["req1", "req2"],
        first_seen=datetime.now(),
        last_seen=datetime.now(),
        trend="increasing",
        potential_time_savings=2.67,
        potential_success_improvement=0.325,
        recommended_evolution="agent"
    )

    evolver = AgentEvolver()

    # Test should_create_agent
    should_create = evolver.should_create_agent(pattern)
    print(f"✓ Should create agent: {should_create}")

    # Generate agent
    agent = evolver.generate_agent_from_pattern(pattern)
    print(f"✓ Generated agent: {agent.class_name}")
    print(f"  Role: {agent.role}")
    print(f"  Department: {agent.department}")
    print(f"  Estimated improvement: +{agent.estimated_improvement['success_rate']:.1%} success")

    # Save agent
    agent_path = evolver.save_agent(agent)

    print("\n✓ Agent Evolver works correctly!")
