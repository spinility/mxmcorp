"""
Prompt Engineer - G√©n√®re des prompts optimis√©s selon le mod√®le cible

Utilise GPT-5 (Claude Sonnet) pour cr√©er des prompts adapt√©s √†:
- nano (gpt-3.5-turbo): Prompts courts, directs, simples
- deepseek: Prompts structur√©s, avec exemples
- claude: Prompts d√©taill√©s, avec raisonnement

D√©tecte automatiquement les contradictions:
- Demande de cr√©er un outil qui existe d√©j√†
- Demande incompatible avec les outils disponibles
"""

from typing import List, Dict, Any, Optional
from cortex.core.llm_client import LLMClient, ModelTier
from cortex.tools.standard_tool import StandardTool


class PromptEngineer:
    """G√©n√®re des prompts optimis√©s selon le contexte et le mod√®le"""

    def __init__(self, llm_client: LLMClient):
        """
        Initialize Prompt Engineer

        Args:
            llm_client: LLM client for GPT-5 calls
        """
        self.llm_client = llm_client

    def detect_contradiction(
        self,
        user_request: str,
        available_tools: List[StandardTool]
    ) -> Optional[Dict[str, Any]]:
        """
        D√©tecte si la requ√™te contient une contradiction

        Args:
            user_request: Requ√™te utilisateur
            available_tools: Outils disponibles

        Returns:
            Dict avec contradiction d√©tect√©e ou None
        """
        # Patterns de contradictions courantes
        create_patterns = [
            "impl√©mente", "implemente", "cr√©e", "cree", "ajoute", "cr√©er", "creer",
            "implement", "create", "add", "make", "build"
        ]

        tool_patterns = [
            "tool", "outil", "fonction", "function", "command", "commande"
        ]

        # Check si c'est une demande de cr√©ation d'outil
        is_tool_creation = (
            any(pattern in user_request.lower() for pattern in create_patterns) and
            any(pattern in user_request.lower() for pattern in tool_patterns)
        )

        if not is_tool_creation:
            return None

        # Chercher quel outil est demand√©
        # M√©thode 1: Par nom d'outil
        for tool in available_tools:
            # Variations du nom (avec/sans underscore, etc.)
            name_variations = [
                tool.name,
                tool.name.replace("_", " "),
                tool.name.replace("_", "-"),
                tool.name.replace("_", "")
            ]

            for variation in name_variations:
                if variation.lower() in user_request.lower():
                    # CONTRADICTION D√âTECT√âE!
                    return {
                        "type": "tool_already_exists",
                        "tool_name": tool.name,
                        "requested_variation": variation,
                        "message": f"L'outil '{tool.name}' existe d√©j√† dans le syst√®me!"
                    }

        # M√©thode 2: Par mots-cl√©s dans la description
        # Mapper des mots-cl√©s √† des outils existants
        keyword_mappings = {
            "delete": ["delete_file"],
            "suppr": ["delete_file"],
            "efface": ["delete_file"],
            "remove": ["delete_file"],
            "create": ["create_file"],
            "cr√©e": ["create_file"],
            "cree": ["create_file"],
            "cr√©er": ["create_file"],
            "creer": ["create_file"],
            "read": ["read_file"],
            "lit": ["read_file"],
            "lire": ["read_file"],
            "append": ["append_to_file"],
            "ajoute": ["append_to_file"],
            "list": ["list_directory"],
            "liste": ["list_directory"],
            "exists": ["file_exists"],
            "existe": ["file_exists"],
            "weather": ["get_weather"],
            "m√©t√©o": ["get_weather"],
            "meteo": ["get_weather"],
            "search": ["web_search"],
            "cherche": ["web_search"],
            "fetch": ["web_fetch"],
        }

        # V√©rifier si la requ√™te contient des mots-cl√©s d'action sur fichiers
        request_lower = user_request.lower()

        for keyword, potential_tools in keyword_mappings.items():
            if keyword in request_lower:
                # V√©rifier si l'outil correspondant existe
                for tool in available_tools:
                    if tool.name in potential_tools:
                        # V√©rifier que c'est bien une demande de cr√©ation d'outil
                        # (et pas juste utilisation de l'outil)
                        if any(p in request_lower for p in ["fichier", "file", "dossier", "directory"]):
                            return {
                                "type": "tool_already_exists",
                                "tool_name": tool.name,
                                "requested_variation": keyword,
                                "message": f"L'outil '{tool.name}' existe d√©j√† dans le syst√®me!"
                            }

        return None

    def build_agent_prompt(
        self,
        tier: ModelTier,
        user_request: str,
        available_tools: List[StandardTool],
        contradiction: Optional[Dict[str, Any]] = None
    ) -> str:
        """
        Construit un prompt optimis√© selon le tier

        Args:
            tier: Tier du mod√®le (nano/deepseek/claude)
            user_request: Requ√™te utilisateur
            available_tools: Outils disponibles
            contradiction: Contradiction d√©tect√©e (optionnelle)

        Returns:
            System prompt optimis√©
        """
        # G√©n√©rer la liste d'outils
        tools_list = self._format_tools_list(available_tools, tier)

        # Si contradiction d√©tect√©e, cr√©er un prompt sp√©cial
        if contradiction:
            return self._build_contradiction_prompt(
                tier, user_request, available_tools, contradiction
            )

        # Sinon, prompt normal selon le tier
        if tier == ModelTier.NANO:
            return self._build_nano_prompt(tools_list)
        elif tier == ModelTier.DEEPSEEK:
            return self._build_deepseek_prompt(tools_list)
        else:  # Claude
            return self._build_claude_prompt(tools_list)

    def _format_tools_list(
        self,
        tools: List[StandardTool],
        tier: ModelTier
    ) -> str:
        """Formate la liste d'outils selon le tier"""
        if tier == ModelTier.NANO:
            # Court et simple pour nano
            return "\n".join([f"- {tool.name}" for tool in tools])
        elif tier == ModelTier.DEEPSEEK:
            # Avec descriptions courtes
            return "\n".join([
                f"- {tool.name}: {tool.description[:60]}..."
                if len(tool.description) > 60
                else f"- {tool.name}: {tool.description}"
                for tool in tools
            ])
        else:  # Claude
            # Complet avec cat√©gories
            categories = {}
            for tool in tools:
                cat = tool.category or "general"
                if cat not in categories:
                    categories[cat] = []
                categories[cat].append(tool)

            result = []
            for cat, cat_tools in categories.items():
                result.append(f"\n{cat.upper()}:")
                for tool in cat_tools:
                    result.append(f"  - {tool.name}: {tool.description}")

            return "\n".join(result)

    def _build_nano_prompt(self, tools_list: str) -> str:
        """Prompt optimis√© pour nano (court, direct)"""
        return f"""Agent with tools. Use them directly.

TOOLS:
{tools_list}

RULES:
1. Have tool? USE IT
2. No tool? Say "Tools Department will create it"
3. Response format:

üéØ Result: [1 sentence]
üí≠ Confidence: [HIGH/MEDIUM/LOW]
‚ö†Ô∏è Severity: [CRITICAL/HIGH/MEDIUM/LOW]
üîß Actions: [Tools used]

Example:
üéØ Result: File created.
üí≠ Confidence: HIGH
‚ö†Ô∏è Severity: LOW
üîß Actions: create_file()"""

    def _build_deepseek_prompt(self, tools_list: str) -> str:
        """Prompt optimis√© pour deepseek (structur√©, exemples)"""
        return f"""Tu es Cortex, un agent avec des outils.

OUTILS DISPONIBLES:
{tools_list}

R√àGLES:
1. Si l'outil existe: UTILISE-LE directement
2. Si l'outil n'existe pas: Informe que le Tools Department va le cr√©er
3. Format de r√©ponse obligatoire:

üéØ **R√©sultat:** [R√©ponse principale claire]

üí≠ **Confiance:** [HAUTE/MOYENNE/FAIBLE] - [Justification courte]

‚ö†Ô∏è **Gravit√© si erreur:** [CRITIQUE/HAUTE/MOYENNE/FAIBLE] - [Impact]

üîß **Actions:** [Outils utilis√©s ou "Aucun outil disponible"]

EXEMPLES:

Requ√™te: "Cr√©e un fichier test.txt"
R√©ponse:
üéØ **R√©sultat:** Fichier test.txt cr√©√© avec succ√®s.
üí≠ **Confiance:** HAUTE - Tool confirm√©.
‚ö†Ô∏è **Gravit√© si erreur:** FAIBLE - Peut recr√©er facilement.
üîß **Actions:** create_file(file_path="test.txt", content="")

Requ√™te: "Quelle est la m√©t√©o √† Paris?"
R√©ponse:
üéØ **R√©sultat:** Tool m√©t√©o non disponible. Demande au Tools Department.
üí≠ **Confiance:** MOYENNE - Tool manquant mais cr√©able.
‚ö†Ô∏è **Gravit√© si erreur:** FAIBLE - Info non critique.
üîß **Actions:** Aucun - Outil "get_weather" requis."""

    def _build_claude_prompt(self, tools_list: str) -> str:
        """Prompt optimis√© pour claude (d√©taill√©, raisonnement)"""
        return f"""Tu es Cortex, un agent intelligent √©quip√© d'outils pour accomplir des t√¢ches.

PHILOSOPHIE:
- Privil√©gier l'action directe avec les outils disponibles
- √ätre transparent sur les limitations
- Fournir des r√©ponses structur√©es et informatives

OUTILS DISPONIBLES:
{tools_list}

PROCESSUS DE D√âCISION:
1. Analyse la requ√™te utilisateur
2. Identifie les outils n√©cessaires
3. Si l'outil existe: ex√©cute-le imm√©diatement
4. Si l'outil manque: explique clairement la situation et propose une solution

FORMAT DE R√âPONSE (OBLIGATOIRE):

üéØ **R√©sultat:** [R√©ponse principale d√©taill√©e en 1-3 phrases]

üí≠ **Confiance:** [HAUTE/MOYENNE/FAIBLE] - [Justification avec contexte]

‚ö†Ô∏è **Gravit√© si erreur:** [CRITIQUE/HAUTE/MOYENNE/FAIBLE] - [Analyse d'impact]

üîß **Actions:** [Liste des outils utilis√©s avec param√®tres, ou explication si aucun]

EXEMPLES D√âTAILL√âS:

Exemple 1 - Outil disponible:
Requ√™te: "Cr√©e un fichier config.json avec des param√®tres par d√©faut"
R√©ponse:
üéØ **R√©sultat:** Fichier config.json cr√©√© avec succ√®s contenant la configuration par d√©faut.
üí≠ **Confiance:** HAUTE - L'outil create_file est disponible et a √©t√© test√©.
‚ö†Ô∏è **Gravit√© si erreur:** FAIBLE - Le fichier peut √™tre recr√©√© sans perte de donn√©es.
üîß **Actions:** create_file(file_path="config.json", content='{{"version": "1.0"}}')

Exemple 2 - Outil manquant:
Requ√™te: "Traduis ce texte en espagnol"
R√©ponse:
üéØ **R√©sultat:** Outil de traduction non disponible. Je vais demander au Tools Department de cr√©er un outil "translate_text" avec support multi-langues.
üí≠ **Confiance:** MOYENNE - L'outil peut √™tre cr√©√© facilement via une API de traduction.
‚ö†Ô∏è **Gravit√© si erreur:** FAIBLE - T√¢che non critique, alternatives manuelles disponibles.
üîß **Actions:** Aucun - Requ√™te de cr√©ation d'outil "translate_text(text, source_lang, target_lang)" envoy√©e au Tools Department."""

    def _build_contradiction_prompt(
        self,
        tier: ModelTier,
        user_request: str,
        available_tools: List[StandardTool],
        contradiction: Dict[str, Any]
    ) -> str:
        """
        Construit un prompt sp√©cial quand une contradiction est d√©tect√©e

        Args:
            tier: Tier du mod√®le
            user_request: Requ√™te utilisateur
            available_tools: Outils disponibles
            contradiction: Info sur la contradiction

        Returns:
            Prompt qui informe de la contradiction
        """
        tool_name = contradiction["tool_name"]

        # Trouver l'outil en question
        tool = next((t for t in available_tools if t.name == tool_name), None)

        if not tool:
            return self.build_agent_prompt(tier, user_request, available_tools, None)

        # Prompt court pour nano, d√©taill√© pour les autres
        if tier == ModelTier.NANO:
            return f"""CONTRADICTION DETECTED!

User requested to create tool "{tool_name}"
BUT this tool ALREADY EXISTS!

Tool: {tool_name}
Description: {tool.description}

Response format:
üéØ Result: Tool already exists!
üí≠ Confidence: HIGH
‚ö†Ô∏è Severity: LOW
üîß Actions: None needed"""

        else:  # DeepSeek et Claude
            return f"""‚ö†Ô∏è CONTRADICTION D√âTECT√âE

La requ√™te utilisateur demande de cr√©er/impl√©menter l'outil "{tool_name}",
MAIS cet outil EXISTE D√âJ√Ä dans le syst√®me!

OUTIL EXISTANT:
  Nom: {tool_name}
  Description: {tool.description}
  Cat√©gorie: {tool.category}
  Tags: {', '.join(tool.tags) if tool.tags else 'aucun'}

INSTRUCTION:
R√©ponds √† l'utilisateur en l'informant que:
1. L'outil "{tool_name}" existe d√©j√†
2. Il est pleinement fonctionnel
3. Propose de l'utiliser directement si la requ√™te peut √™tre reformul√©e

FORMAT DE R√âPONSE:

üéØ **R√©sultat:** L'outil "{tool_name}" existe d√©j√† dans le syst√®me! Aucune impl√©mentation n√©cessaire.

üí≠ **Confiance:** HAUTE - Outil v√©rifi√© et fonctionnel.

‚ö†Ô∏è **Gravit√© si erreur:** FAIBLE - Aucune erreur, juste une clarification.

üîß **Actions:** Aucune - L'outil est d√©j√† disponible pour utilisation.

SUGGESTION: Propose √† l'utilisateur d'utiliser l'outil directement en reformulant sa requ√™te."""


def create_prompt_engineer(llm_client: LLMClient) -> PromptEngineer:
    """Factory function to create a PromptEngineer"""
    return PromptEngineer(llm_client)
